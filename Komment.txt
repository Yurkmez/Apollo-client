Интересные решения

_________App.jsx
стр.25__________
Мы напрямую передаем инструкцию в useState
результат работы компонента:
"
onClick={() =>
    setState(<GetAllPosts postLimit={Number(postLimit)} />)
   }
"
он возвращает состояние (state), которое отображается на стр.33
________getAllPosts.jsx
Самое интересное здесь 
"
    const listItemRef = useRef([]);
"
Зачем нам здесь нужно использолвание useRef?
Как известно, его применение служит 2 целям:
- хранению изменяемых значений, 
  которые не вызывают повторный рендеринг при обновлении,
  (см. здесь пример со счетчиком)
- хранению ссылок на элементы DOM.
Здесь мы его применяем для сохранению ссылки на элементы <li></li>
"
    <li
        ref={(el) => (listItemRef.current[post.id] = el)}
            key={post.id}
    >
"
Когда мы производим "UpdatePost", то мы передаем его туда
"
    <UpdatePost post={post.data.post} item={listItemRef} />
"
в нем передаем в 
"
    <DeletePost {...props} />
"
где в их составе item
"
    const props = {
        post,
        setAllState,
        item,
    };
"
и когда мы удаляем пост, то:
"
    item.current[post.id].remove();
"
то удаляем соответствующий элемент DOM <li></li>
т.о., список постов обновляется (показывается уже без удаленного поста)

